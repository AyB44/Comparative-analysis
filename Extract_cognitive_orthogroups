#!/usr/bin/env python3
# extract_cognitive_genes.py
"""
Extract genes for selected GO terms from an EggNOG-mapper .emapper.annotations TSV.
Minimal, stdlib-only.
"""

import argparse, csv, re
from pathlib import Path

DEFAULT_GO = {
    "GO:0007613": "memory",
    "GO:0007611": "learning",
    "GO:0048878": "neuron_differentiation",
    "GO:0099536": "synaptic_signaling",
    "GO:0007420": "brain_development",
    "GO:0007399": "nervous_system_development",
    "GO:0050804": "modulation_of_chemical_synaptic_transmission",
    "GO:0097060": "synapse_organization",
    "GO:0007268": "synaptic_transmission",
}
GO_RE = re.compile(r"GO:\d{7}")

def load_go_map(go_file: Path | None) -> dict[str, str]:
    if not go_file:
        return dict(DEFAULT_GO)
    mapping: dict[str, str] = {}
    with go_file.open("r", encoding="utf-8") as fh:
        dialect = csv.Sniffer().sniff(fh.read(2048), delimiters=",\t")
        fh.seek(0)
        for row in csv.reader(fh, dialect):
            if not row or row[0].startswith("#"): continue
            if len(row) < 2: raise ValueError(f"GO map row needs 2 columns: {row}")
            mapping[row[0].strip()] = row[1].strip()
    return mapping

def main():
    ap = argparse.ArgumentParser(description="Extract cognitive GO genes from EggNOG annotations.")
    ap.add_argument("-a","--annotations", required=True, type=Path, help=".emapper.annotations (TSV)")
    ap.add_argument("-o","--outdir", default=Path("cognitive_go_outputs"), type=Path)
    ap.add_argument("--go-file", type=Path, help="Two-column file: GO_ID <tab/comma> label")
    ap.add_argument("--go-col", type=int, default=9, help="0-based GO column index (EggNOG v2: 9)")
    ap.add_argument("--gene-col", type=int, default=0, help="0-based gene/query column index")
    args = ap.parse_args()

    if not args.annotations.exists():
        raise FileNotFoundError(args.annotations)

    go_map = load_go_map(args.go_file)
    target = set(go_map.keys())
    per_go: dict[str, set[str]] = {g: set() for g in target}
    per_gene: dict[str, set[str]] = {}

    with args.annotations.open("r", encoding="utf-8", newline="") as fh:
        reader = csv.reader(fh, delimiter="\t")
        max_idx = max(args.go_col, args.gene_col)
        for row in reader:
            if not row or row[0].startswith("#") or len(row) <= max_idx: 
                continue
            gene = row[self:=args.gene_col].strip()
            go_field = row[args.go_col].strip()
            if not go_field or go_field.upper() == "NA": 
                continue
            hits = set(GO_RE.findall(go_field)) & target
            if not hits: 
                continue
            per_gene.setdefault(gene, set()).update(hits)
            for go in hits:
                per_go[go].add(gene)

    args.outdir.mkdir(parents=True, exist_ok=True)
    for go_id, genes in per_go.items():
        label = go_map[go_id]
        out = args.outdir / f"cognitive_genes_{go_id}_{label}.txt"
        out.write_text("\n".join(sorted(genes)) + ("\n" if genes else ""), encoding="utf-8")
        print(f"{go_id} ({label}): {len(genes)} genes → {out}")

    summary = args.outdir / "cognitive_genes_summary.tsv"
    with summary.open("w", encoding="utf-8", newline="") as out:
        w = csv.writer(out, delimiter="\t")
        w.writerow(["gene_id","matched_go_ids","matched_labels"])
        for gene, gos in sorted(per_gene.items()):
            ids = sorted(gos)
            labels = [go_map[g] for g in ids]
            w.writerow([gene, ",".join(ids), ",".join(labels)])
    print(f"Wrote summary → {summary}")

if __name__ == "__main__":
    main()
